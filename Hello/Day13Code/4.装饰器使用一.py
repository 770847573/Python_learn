# 1.闭包
def func1():
    n = 45
    def func2():
        print(n)
    return func2
# 方式一
f = func1()
f()
# 方式二
func1()()

# 2.
"""
假设我们要增强某个函数的功能,但又不希望修改原函数的定义，
这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）
"""
# 装饰器的本质：实际上是一个闭包
# 闭包的书写形式
# 方式一
def outter1(a):
    def inner1(b):
        print(a,b)
    return inner1
f1 = outter1(3)
f1(4)

# 方式二
def outter1(a):
    def inner1(b):
        print(a,b)
    inner1(79)
outter1(3)

# 实现装饰器，使用方式一

# 3.装饰器的语法
def now():       # 7
    print("拼搏到无能为力，坚持到感动自己")

# 需求：给now函数增加一个新的功能，但是要求不能修改now函数
# 装饰器的书写步骤
# a.书写一个闭包，外部函数的函数名其实就是装饰器的名称
# b.给外部函数设置参数，该参数表示需要被装饰的函数,一般命名为func,fun,f...
def outter(func):       # 2
    def inner():      # 3,5
        # c.调用原函数
        func()   # 在内部函数中调用了外部函数中的变量      6

        # d.新增功能
        print("new~~~~")      # 8
    # e.inner中包含了原函数的功能和新的功能，也就是原函数被装饰器之后的结果， 所以必须将装饰之后的结果返回
    return inner        # 3

# f.调用外部函数【装饰器】，将原函数作为参数传递
f = outter(now)   # func = now    f = inner       1
f()       # 4

"""
掌握：
    a.语法
    b.执行顺序
    
使用场景:
    在实际项目开发中，有ABC三个人同时开发同一个项目
    对于整个项目中的公共文件，一个公共文件有可能在多个地方
    如果其中一个人需要使用公共文件中的功能，但是还需要增加新的功能，一定不能直接修改文件，可以使用装饰器
"""

"""
注意：
    a.好处：在不修改原函数的基础上增加新的功能
    b.调用原函数和增加新功能没有绝对的先后顺序，根据具体的需求进行调整
    c.装饰器实际上还是普通的函数，所以一定要注意参数的匹配
"""





